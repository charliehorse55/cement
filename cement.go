package main

import (
	"flag"
	"fmt"
	"log"
	"runtime"
	"time"
	"image"
	"os"
	_ "image/png"
	_ "image/jpeg"
	Ecem "github.com/charliehorse55/libcement"
    glfw "github.com/go-gl/glfw3"
    gl "github.com/go-gl/gl"
)

type intensityController interface {
	Begin(w *glfw.Window, num int) error
	Update(intensity []float32) error
}

var controller intensityController
var currIntensity []float32

func getImageRes(filename string) (int, int, error) {
	file, err := os.Open(filename)
	if err != nil {
		return 0, 0, err
	}
	defer file.Close()
	
	config, _, err := image.DecodeConfig(file)
	if err != nil {
		return 0, 0, err
	}
	
	return config.Width, config.Height, nil
}


// OpenGL and glfw need to be called from the main thread
func init() {
    runtime.LockOSThread()
}

func checkGLError() {
	glErr := gl.GetError()
	if glErr != 0 {
		log.Printf("GL Error Code: %d\n", int(glErr))
		panic("stack trace")
	}
}

func errorCallback(err glfw.ErrorCode, desc string) {
    log.Fatalf("%v: %v\n", err, desc)
}

func main() {
	flag.Parse()
	
	imagePaths := flag.Args()
	
	currIntensity = make([]float32, len(imagePaths))
	
	// if len(imagePaths) < 2 || len(imagePaths) > 10 {
	// 	log.Fatalf("Ecement requires n files, where 2 <= n <= 10\n")
	// }	
	
	width, height, err := getImageRes(imagePaths[0])
	if err != nil {
		log.Fatalf("Failed to read image: %v\n", err)
	}
	
	controller = &keyScroll{}
	// controller = &keyboard{}
	// controller = &sincos{}
	
	glfw.SetErrorCallback(errorCallback)
    if !glfw.Init() {
        return
    }
    defer glfw.Terminate()

	// Get the right version of OpenGL
	glfw.WindowHint(glfw.OpenglForwardCompatible, glfw.True)
	glfw.WindowHint(glfw.OpenglProfile, glfw.OpenglCoreProfile)
	glfw.WindowHint(glfw.ContextVersionMajor, 3)
	glfw.WindowHint(glfw.ContextVersionMinor, 2)
	
	//we don't handle this properly yet
	glfw.WindowHint(glfw.Resizable, glfw.False)

	_, monitorHeight, err := monitorResolution()
	if err != nil {
		log.Fatalf("Failed to discover monitor resolution: %v", err)
	}
	
	//create a window that is 80% of the monitors height,
	//with a width based on the aspect ratio of the input images
	windowHeight := int(0.8 * float64(monitorHeight))
	windowWidth := int(float64(width)/float64(height) * float64(windowHeight))

	window, err := openWindow("cement", windowWidth, windowHeight)
	if err != nil {
		log.Fatalf("Failed to open window: %v", err)
	}

	result := gl.Init()
	if result != 0 {
		log.Fatalf("Failed to initialize GLEW: %d", result)
	}
	//clear a spurious error sometimes generated by GLEW's initialization 
	gl.GetError()

	err = controller.Begin(window, len(imagePaths))
	if err != nil {
		log.Fatalf("Failed to initialze controller: %v", err)
	}
	
	// //just drawing a rectangle
	// VAO := gl.GenVertexArray()
	// VAO.Bind()
	// vertices := []float32{
	// 	0.0, 1.0,	  // Top-left
	// 	1.0, 1.0,     // Top-right
	// 	1.0, 0.0,     // Bottom-right
	// 	0.0, 0.0,     // Bottom-left
	// }
	// vertexBuf := gl.GenBuffer()
	// vertexBuf.Bind(gl.ARRAY_BUFFER)
	// gl.BufferData(gl.ARRAY_BUFFER, 4*len(vertices), vertices, gl.STATIC_DRAW)
	// 
	// elements := []uint32{
	// 	0, 1, 2,
	// 	2, 3, 0,
	// }
	// elementBuf := gl.GenBuffer()
	// elementBuf.Bind(gl.ELEMENT_ARRAY_BUFFER)
	// gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, 4*len(elements), elements, gl.STATIC_DRAW)
	
	
	Ecem.Start()
	
	//load the textures
	scene := make(Ecem.Painting, len(imagePaths))
	for i, path := range imagePaths {
		scene[i].Filename = path
		scene[i].Intensity.R = 1.0
		scene[i].Intensity.G = 1.0
		scene[i].Intensity.B = 1.0
	}
	err = scene.Load(true)
	if err != nil {
		log.Fatalf("Failed to load images: %v")
	}
	
	screenRender := scene.CreateRendering(windowWidth, windowHeight)
	
	screenFB := gl.Framebuffer(0)
				
	lastUpdated := time.Now()
	frames := 0
	// shouldSave := false
	// rawOutput := make([]Pixel, width*height)
	done := make(chan int, 100)
	saveOperations := 0
    for !window.ShouldClose() {
		frames++
					
		err = controller.Update(currIntensity)
		if err != nil {
			log.Printf("Failed to update controller state: %v", err)
			return
		}
		for i := range scene {
			scene[i].Intensity.R = currIntensity[i]
			scene[i].Intensity.G = currIntensity[i]
			scene[i].Intensity.B = currIntensity[i]
		}
		
		//render to the screen
		screenRender.Update()
				
		screenFB.Bind()
		gl.Viewport(0, 0, windowWidth, windowHeight)
		screenRender.Tonemap()

		checkGLError()		
	
		//save the output if the user wanted to
		// if shouldSave {
		// 	step.Use()
		// 	gl.Viewport(0,0, width, height)
		// 	result := render(vectors, fullSizeFBs, intensitylocation)
		// 	
		// 	gl.ActiveTexture(gl.TEXTURE0)
		// 	result.Bind(gl.TEXTURE_2D)
		// 
		// 	final.Use()
		// 	gl.DrawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, nil)
		// 	
		// 	gl.ReadPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, rawOutput)
		// 
		// 	go func() {
		// 		path := "output.jpg"
		// 		err := saveToJPEG(path, width, height, rawOutput)
		// 		if err != nil {
		// 			log.Printf("Failed to save jpeg: %v", err)
		// 		}
		// 		done <- 1
		// 	}()
		// 	saveOperations++
		// 	shouldSave = false	
		// }
				
		glfw.PollEvents()
		now := time.Now()
		diff := now.Sub(lastUpdated)
		if diff > time.Second*2 {
			fmt.Printf("%.1f FPS\n", float64(frames)/diff.Seconds())
			lastUpdated = now
			frames = 0
		}
		
		window.SwapBuffers()
    }
	
	//wait for any remaining saves to complete
	for i := 0; i < saveOperations; i++ {
		<-done
	}	
}