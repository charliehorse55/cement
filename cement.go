package main

import (
	"flag"
	"fmt"
	"log"
	"runtime"
	"time"
	"image"
	"os"
	"image/color"
	_ "image/png"
	"image/jpeg"
	Ecem "github.com/charliehorse55/libcement"
    glfw "github.com/go-gl/glfw3"
    gl "github.com/go-gl/gl"
)

type intensityController interface {
	Begin(w *glfw.Window, num int) error
	Update(p Ecem.Painting) error
	ShouldSave() bool
}

var controller intensityController

func getImageRes(filename string) (int, int, error) {
	file, err := os.Open(filename)
	if err != nil {
		return 0, 0, err
	}
	defer file.Close()
	
	config, _, err := image.DecodeConfig(file)
	if err != nil {
		return 0, 0, err
	}
	
	return config.Width, config.Height, nil
}

type Pixel struct {
	R,G,B,A float32
}

func saveToJPEG(filename string, width, height int, data []Pixel) error {	
	output := image.NewNRGBA(image.Rectangle{Max: image.Point{X:width, Y:height}})
	for i := 0; i < height; i++ {
		for j := 0; j < width; j++ {
			
			//prevent overflow for each channel when packed into 8 bits
			red := data[i*width +j].R*255
			if red > 255 {
				red = 255
			}
			green := data[i*width +j].G*255
			if green > 255 {
				green = 255
			}
			blue := data[i*width +j].B*255
			if blue > 255 {
				blue = 255
			}
	
			output.Set(j, height - (i+1), color.NRGBA{
					R:uint8(red),
					G:uint8(green),
					B:uint8(blue),
					A:uint8(255),
				})
		}
	}
		
	outfile, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("Failed to open output file: %s", filename)
	}
	defer outfile.Close()

	err = jpeg.Encode(outfile, output, nil)
	if err != nil {
		return fmt.Errorf("Failed to encode output file: %v", err)
	}
	
	return nil
}


// OpenGL and glfw need to be called from the main thread
func init() {
    runtime.LockOSThread()
}

func checkGLError() {
	glErr := gl.GetError()
	if glErr != 0 {
		log.Printf("GL Error Code: %d\n", int(glErr))
		panic("stack trace")
	}
}

func errorCallback(err glfw.ErrorCode, desc string) {
    log.Fatalf("%v: %v\n", err, desc)
}

func main() {
	flag.Parse()
	
	imagePaths := flag.Args()
			
	width, height, err := getImageRes(imagePaths[0])
	if err != nil {
		log.Fatalf("Failed to read image: %v\n", err)
	}
	
	controller = &keyScroll{}
	// controller = &keyboard{}
	// controller = &sincos{}
	
	glfw.SetErrorCallback(errorCallback)
    if !glfw.Init() {
        return
    }
    defer glfw.Terminate()

	// Get the right version of OpenGL
	glfw.WindowHint(glfw.OpenglForwardCompatible, glfw.True)
	glfw.WindowHint(glfw.OpenglProfile, glfw.OpenglCoreProfile)
	glfw.WindowHint(glfw.ContextVersionMajor, 3)
	glfw.WindowHint(glfw.ContextVersionMinor, 2)
	
	//we don't handle this properly yet
	glfw.WindowHint(glfw.Resizable, glfw.False)

	_, monitorHeight, err := monitorResolution()
	if err != nil {
		log.Fatalf("Failed to discover monitor resolution: %v", err)
	}
	
	//create a window that is 80% of the monitors height,
	//with a width based on the aspect ratio of the input images
	windowHeight := int(0.8 * float64(monitorHeight))
	windowWidth := int(float64(width)/float64(height) * float64(windowHeight))

	window, err := openWindow("cement", windowWidth, windowHeight)
	if err != nil {
		log.Fatalf("Failed to open window: %v", err)
	}

	result := gl.Init()
	if result != 0 {
		log.Fatalf("Failed to initialize GLEW: %d", result)
	}
	//clear a spurious error sometimes generated by GLEW's initialization 
	gl.GetError()

	err = controller.Begin(window, len(imagePaths))
	if err != nil {
		log.Fatalf("Failed to initialze controller: %v", err)
	}
	
	// //just drawing a rectangle
	// VAO := gl.GenVertexArray()
	// VAO.Bind()
	// vertices := []float32{
	// 	0.0, 1.0,	  // Top-left
	// 	1.0, 1.0,     // Top-right
	// 	1.0, 0.0,     // Bottom-right
	// 	0.0, 0.0,     // Bottom-left
	// }
	// vertexBuf := gl.GenBuffer()
	// vertexBuf.Bind(gl.ARRAY_BUFFER)
	// gl.BufferData(gl.ARRAY_BUFFER, 4*len(vertices), vertices, gl.STATIC_DRAW)
	// 
	// elements := []uint32{
	// 	0, 1, 2,
	// 	2, 3, 0,
	// }
	// elementBuf := gl.GenBuffer()
	// elementBuf.Bind(gl.ELEMENT_ARRAY_BUFFER)
	// gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, 4*len(elements), elements, gl.STATIC_DRAW)
	
	
	Ecem.Start()
	
	//load the textures
	scene := make(Ecem.Painting, len(imagePaths))
	for i, path := range imagePaths {
		scene[i].Filename = path
		scene[i].Intensity.R = 1.0
		scene[i].Intensity.G = 1.0
		scene[i].Intensity.B = 1.0
	}
	err = scene.Load(true)
	if err != nil {
		log.Fatalf("Failed to load images: %v")
	}
	
	screenRender := scene.CreateRendering(windowWidth, windowHeight)
	fileRender := scene.CreateRendering(width, height)
	
	screenFB := gl.Framebuffer(0)
				
	lastUpdated := time.Now()
	frames := 0
	rawOutput := make([]Pixel, width*height)
	done := make(chan int, 100)
	saveOperations := 0
    for !window.ShouldClose() {
		frames++
					
		err = controller.Update(scene)
		if err != nil {
			log.Printf("Failed to update controller state: %v", err)
			return
		}
		
		//render to the screen
		screenRender.Update()
				
		screenFB.Bind()
		gl.Viewport(0, 0, windowWidth, windowHeight)
		screenRender.Tonemap()

		checkGLError()		
	
		//save the output if the user wanted to
		if controller.ShouldSave() {
			fileRender.Update()			
			Ecem.FB.Bind()
		 	gl.FramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fileRender.BackBuffer, 0)
			gl.Viewport(0, 0, width, height)
			fileRender.Tonemap()
			
			gl.ReadPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, rawOutput)
		
			go func() {
				path := "output.jpg"
				err := saveToJPEG(path, width, height, rawOutput)
				if err != nil {
					log.Printf("Failed to save jpeg: %v", err)
				}
				done <- 1
			}()
			saveOperations++
		}
				
		glfw.PollEvents()
		now := time.Now()
		diff := now.Sub(lastUpdated)
		if diff > time.Second*2 {
			fmt.Printf("%.1f FPS\n", float64(frames)/diff.Seconds())
			lastUpdated = now
			frames = 0
		}
		
		window.SwapBuffers()
    }
	
	//wait for any remaining saves to complete
	for i := 0; i < saveOperations; i++ {
		<-done
	}	
}