package main

import (
	"os"
	"fmt"
	"log"
	"flag"
	"time"
	"image"
	"runtime"
    "path/filepath"
    gl "github.com/go-gl/gl"
    glfw "github.com/go-gl/glfw3"
	Ecem "github.com/charliehorse55/libcement"
)

type intensityController interface {
	Begin(w *glfw.Window, intensity []Ecem.RGB32f) error
	ShouldSave() bool
}

var controller intensityController



// OpenGL and glfw need to be called from the main thread
func init() {
    runtime.LockOSThread()
}

func checkGLError() {
	glErr := gl.GetError()
	if glErr != 0 {
		log.Printf("GL Error Code: %d\n", int(glErr))
		panic("stack trace")
	}
}

func createTexture(img *image.NRGBA) gl.Texture {
	result := gl.GenTexture()
	result.Bind(gl.TEXTURE_2D)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
	dim := img.Bounds().Max
    gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, dim.X, dim.Y, 0, gl.RGBA, gl.UNSIGNED_BYTE, img.Pix)
	return result
}

func errorCallback(err glfw.ErrorCode, desc string) {
    log.Fatalf("%v: %v\n", err, desc)
}

func main() {
    var useKeyboard bool
    flag.BoolVar(&useKeyboard, "piano", false, "Use piano style control")
    
	flag.Parse()
	
	inputFiles := flag.Args()
	
	if len(inputFiles) == 0 {
		fmt.Fprintf(os.Stderr, "cement requires input files\n")
		return
	}
	
	var cfg *Config
	if len(inputFiles) == 1 {
		var err error
		cfg, err = LoadConfig(inputFiles[0])
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to read config at %s: %v\n", inputFiles[0], err)
		}
	} else {
		cfg = new(Config)
		cfg.filepath = "out.json"
		cfg.Background = inputFiles[0]
		cfg.Vectors = make([]Lightvector, len(inputFiles) - 1)
		for i,path := range inputFiles[1:] {
			cfg.Vectors[i].Intensity = Ecem.RGB32f{1.0, 1.0, 1.0}
			cfg.Vectors[i].Filename = path
		}
	}
	
	width, height, err := getImageRes(filepath.Join(cfg.basePath, cfg.Vectors[0].Filename))
	if err != nil {
		log.Fatalf("Failed to read image: %v\n", err)
	}
	
    if useKeyboard {
        controller = &keyboard{}
    } else {
        controller = &keyScroll{}
    }
	// controller = &sincos{}
	
	glfw.SetErrorCallback(errorCallback)
    if !glfw.Init() {
        return
    }
    defer glfw.Terminate()

	// Get the right version of OpenGL
	glfw.WindowHint(glfw.OpenglForwardCompatible, glfw.True)
	glfw.WindowHint(glfw.OpenglProfile, glfw.OpenglCoreProfile)
	glfw.WindowHint(glfw.ContextVersionMajor, 3)
	glfw.WindowHint(glfw.ContextVersionMinor, 2)
	
	//we don't handle this properly yet
	glfw.WindowHint(glfw.Resizable, glfw.False)

	_, monitorHeight, err := monitorResolution()
	if err != nil {
		log.Fatalf("Failed to discover monitor resolution: %v", err)
	}
	
	//create a window that is 80% of the monitors height,
	//with a width based on the aspect ratio of the input images
	windowHeight := int(0.8 * float64(monitorHeight))
	windowWidth := int(float64(width)/float64(height) * float64(windowHeight))

	window, err := openWindow("cement", windowWidth, windowHeight)
	if err != nil {
		log.Fatalf("Failed to open window: %v", err)
	}

	result := gl.Init()
	if result != 0 {
		log.Fatalf("Failed to initialize GL: %d", result)
	}
	//clear a spurious error sometimes generated by GLEW's initialization 
	gl.GetError()
	
	// //just drawing a rectangle
	// VAO := gl.GenVertexArray()
	// VAO.Bind()
	// vertices := []float32{
	// 	0.0, 1.0,	  // Top-left
	// 	1.0, 1.0,     // Top-right
	// 	1.0, 0.0,     // Bottom-right
	// 	0.0, 0.0,     // Bottom-left
	// }
	// vertexBuf := gl.GenBuffer()
	// vertexBuf.Bind(gl.ARRAY_BUFFER)
	// gl.BufferData(gl.ARRAY_BUFFER, 4*len(vertices), vertices, gl.STATIC_DRAW)
	// 
	// elements := []uint32{
	// 	0, 1, 2,
	// 	2, 3, 0,
	// }
	// elementBuf := gl.GenBuffer()
	// elementBuf.Bind(gl.ELEMENT_ARRAY_BUFFER)
	// gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, 4*len(elements), elements, gl.STATIC_DRAW)
	
	
	Ecem.Start()
		
	scene, err := cfg.LoadPainting()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to load painting: %v\n", err)
		return
	}

	intensity := make([]Ecem.RGB32f, len(cfg.Vectors))
	for i := range intensity {
		intensity[i] = cfg.Vectors[i].Intensity
	}
	
	err = controller.Begin(window, intensity)
	if err != nil {
		log.Fatalf("Failed to initialze controller: %v", err)
	}
	
	screenRender := scene.CreateRendering(windowWidth, windowHeight, intensity)
	fileRender := scene.CreateRendering(width, height, intensity)
	
	screenFB := gl.Framebuffer(0)
				
	lastUpdated := time.Now()
	frames := 0
	rawOutput := make([]Pixel, width*height)
	done := make(chan int, 100)
	saveOperations := 0
    for !window.ShouldClose() {
		frames++
							
		//render to the screen
		screenRender.Update(intensity)
		checkGLError()		
				
		screenFB.Bind()
		checkGLError()		
		
		gl.Viewport(0, 0, windowWidth, windowHeight)
		checkGLError()		
		
		screenRender.Tonemap()

		checkGLError()		
	
		//save the output if the user wanted to
		if controller.ShouldSave() {
			start := time.Now()
			fileRender.Update(intensity)			
			Ecem.FB.Bind()
		 	gl.FramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fileRender.BackBuffer, 0)
			gl.Viewport(0, 0, width, height)
			fileRender.Tonemap()
			
			gl.ReadPixels(0, 0, width, height, gl.RGB, gl.FLOAT, rawOutput)
			fmt.Printf("Render: %fs\n", time.Since(start).Seconds())
			
			//set the intensity to the current intensity
			for i := range intensity {
				cfg.Vectors[i].Intensity = intensity[i]
			}
		
			go func() {
				path := filepath.Join(cfg.basePath, "output.jpg")
				err := saveToJPEG(path, width, height, rawOutput)
				if err != nil {
					log.Printf("Failed to save jpeg: %v", err)
				}
				
				err = cfg.Save(cfg.filepath)				
				if err != nil {
					log.Printf("Failed to save config: %v", err)
				}
				done <- 1
			}()
			saveOperations++
		}
				
		glfw.PollEvents()
		now := time.Now()
		diff := now.Sub(lastUpdated)
		if diff > time.Second*5 {
			fmt.Printf("%.1f FPS\n", float64(frames)/diff.Seconds())
			lastUpdated = now
			frames = 0
		}
		
		window.SwapBuffers()
    }
	
	//wait for any remaining saves to complete
	for i := 0; i < saveOperations; i++ {
		<-done
	}	
}